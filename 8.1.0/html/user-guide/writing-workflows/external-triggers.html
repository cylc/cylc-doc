<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>External Triggers &mdash; Cylc 8.1.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/diff_selector.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/grid_table.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/hieroglyph_theme_addons.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/tutorial.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/addons.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/cylc-favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/js/diff_selector.js"></script>
        <script src="../../_static/js/minicylc.js"></script>
        <script src="../../_static/js/spoiler.js"></script>
        <script src="../../_static/js/addons.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Suicide Triggers" href="suicide-triggers.html" />
    <link rel="prev" title="EmPy" href="empy.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html">
            <img src="../../_static/cylc-logo-white.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                8.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../7-to-8/index.html">Cylc 8 Migration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">User Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Writing Workflows</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="configuration.html">Workflow Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="scheduling.html">Scheduling Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="runtime.html">Task Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="parameterized-tasks.html">Task Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="jinja2.html">Jinja2</a></li>
<li class="toctree-l3"><a class="reference internal" href="empy.html">EmPy</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">External Triggers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#built-in-clock-triggers">Built-in Clock Triggers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#built-in-workflow-state-triggers">Built-in Workflow State Triggers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#custom-trigger-functions">Custom Trigger Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#current-limitations">Current Limitations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#filesystem-events">Filesystem Events?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#continuous-event-watchers">Continuous Event Watchers?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#push-external-triggers">Push External Triggers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#triggering-off-of-tasks-in-other-workflows">Triggering Off Of Tasks In Other Workflows</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="suicide-triggers.html">Suicide Triggers</a></li>
<li class="toctree-l3"><a class="reference internal" href="scheduler.html">Scheduler Configuration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../installing-workflows.html">Installing Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-workflows/index.html">Running Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../task-implementation/index.html">Task Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../removing-workflows.html">Removing Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sharing-access-to-workflows.html">Authorizing Others to Access Your Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../compound-commands.html">Compound Commands</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../plugins/index.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../workflow-design-guide/index.html">Workflow Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Cylc</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">User Guide</a></li>
          <li class="breadcrumb-item"><a href="index.html">Writing Workflows</a></li>
      <li class="breadcrumb-item active">External Triggers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/user-guide/writing-workflows/external-triggers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="external-triggers">
<span id="section-external-triggers"></span><h1>External Triggers<a class="headerlink" href="#external-triggers" title="Permalink to this heading"></a></h1>
<p>External triggers allow tasks to trigger directly off of external events, which
is often preferable to implementing long-running polling tasks in the workflow.
The triggering mechanism described in this section is intended to replace the one
one documented in <a class="reference internal" href="#old-style-external-triggers"><span class="std std-ref">Push External Triggers</span></a> (however, that one is a push
mechanism, whereas this one involves regular polling by the scheduler).</p>
<p>If you can write a Python function to check the status of an external
condition or event, the <a class="reference internal" href="../../glossary.html#term-scheduler"><span class="xref std std-term">scheduler</span></a> can call it at configurable
intervals until it reports success, at which point dependent tasks can trigger
and data returned by the function will be passed to the job environments of
those tasks. Functions can be written for triggering off of almost anything,
such as delivery of a new dataset, creation of a new entry in a database
table, or appearance of new data availability notifications in a message
broker.</p>
<p>Cylc has several built-in external trigger functions:</p>
<ul class="simple">
<li><p>clock triggers - see <a class="reference internal" href="#built-in-clock-triggers"><span class="std std-ref">Built-in Clock Triggers</span></a></p></li>
<li><p>inter-workflow triggers - see <a class="reference internal" href="#built-in-workflow-state-triggers"><span class="std std-ref">Built-in Workflow State Triggers</span></a></p></li>
</ul>
<p>Trigger functions are normal Python functions, with certain constraints as
described below in:</p>
<ul class="simple">
<li><p>custom trigger functions - see <a class="reference internal" href="#custom-trigger-functions"><span class="std std-ref">Custom Trigger Functions</span></a></p></li>
</ul>
<p>External triggers are configured in the
<a class="reference internal" href="../../reference/config/workflow.html#flow.cylc[scheduling][xtriggers]" title="flow.cylc[scheduling][xtriggers]"><code class="xref cylc cylc-conf docutils literal notranslate"><span class="pre">flow.cylc[scheduling][xtriggers]</span></code></a> section.</p>
<section id="built-in-clock-triggers">
<span id="id1"></span><h2>Built-in Clock Triggers<a class="headerlink" href="#built-in-clock-triggers" title="Permalink to this heading"></a></h2>
<p>These are more transparent (exposed in the graph) and efficient (shared among
dependent tasks) than the older clock triggers described
in <a class="reference internal" href="scheduling.html#clocktriggertasks"><span class="std std-ref">Clock Triggers</span></a>.</p>
<p>Clock triggers, unlike other trigger functions, are executed synchronously in
the main process. The clock trigger function signature looks like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">wall_clock</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">offset</span></code> argument is a datetime duration (<code class="docutils literal notranslate"><span class="pre">PT1H</span></code> is 1
hour) relative to the dependent task’s cycle point (automatically passed to the
function via a second argument not shown above).</p>
<p>In the following workflow, task <code class="docutils literal notranslate"><span class="pre">foo</span></code> has a daily cycle point sequence,
and each task instance can trigger once the wallclock time has passed its
cycle point value by one hour:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduling]</span>
    <span class="nv">initial cycle point </span><span class="o">=</span><span class="s"> 2018-01-01</span>
    <span class="nt">[[xtriggers]]</span>
        <span class="nv">clock_1 </span><span class="o">=</span><span class="s"> wall_clock(offset=PT1H):PT10S</span>
    <span class="nt">[[graph]]</span>
        <span class="nv">P1D = &quot;@clock_1 </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">foo</span><span class="c">&quot;</span>
<span class="nt">[runtime]</span>
    <span class="nt">[[foo]]</span>
        <span class="nv">script </span><span class="o">=</span><span class="s"> run-foo.sh</span>
</pre></div>
</div>
<p>Notice that the short label <code class="docutils literal notranslate"><span class="pre">clock_1</span></code> is used to represent the
trigger function in the graph. The function call interval, which determines how
often the <a class="reference internal" href="../../glossary.html#term-scheduler"><span class="xref std std-term">scheduler</span></a> checks the clock, is optional. Here it is
<code class="docutils literal notranslate"><span class="pre">PT10S</span></code> (i.e. 10 seconds, which is also the default value).</p>
<p>Argument keywords can be omitted if called in the right order, so the
<code class="docutils literal notranslate"><span class="pre">clock_1</span></code> trigger can also be declared like this:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[[xtriggers]]</span>
    <span class="nv">clock_1 </span><span class="o">=</span><span class="s"> wall_clock(PT1H)</span>
</pre></div>
</div>
<p>A zero-offset clock trigger does not need to be declared under
the <a class="reference internal" href="../../reference/config/workflow.html#flow.cylc[scheduling][xtriggers]" title="flow.cylc[scheduling][xtriggers]"><code class="xref cylc cylc-conf docutils literal notranslate"><span class="pre">[xtriggers]</span></code></a> section:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduling]</span>
    <span class="nv">initial cycle point </span><span class="o">=</span><span class="s"> 2018-01-01</span>
    <span class="nt">[[graph]]</span>
         <span class="c1"># zero-offset clock trigger:</span>
        <span class="nv">P1D = &quot;@wall_clock </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">foo</span><span class="c">&quot;</span>
<span class="nt">[runtime]</span>
    <span class="nt">[[foo]]</span>
        <span class="nv">script </span><span class="o">=</span><span class="s"> run-foo.sh</span>
</pre></div>
</div>
<p>However, when xtriggers are declared the name used must adhere to the following
rules:</p>
<dl class="py class">
<dt class="sig sig-object py" id="cylc.flow.unicode_rules.XtriggerNameValidator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cylc.flow.unicode_rules.</span></span><span class="sig-name descname"><span class="pre">XtriggerNameValidator</span></span><a class="headerlink" href="#cylc.flow.unicode_rules.XtriggerNameValidator" title="Permalink to this definition"></a></dt>
<dd><p>The rules for valid xtrigger labels:</p>
<ul class="simple">
<li><p>can only contain: latin letters and numbers, <code class="docutils literal notranslate"><span class="pre">_</span></code></p></li>
<li><p>cannot start with: <code class="docutils literal notranslate"><span class="pre">_cylc</span></code></p></li>
</ul>
</dd></dl>

</section>
<section id="built-in-workflow-state-triggers">
<span id="id2"></span><h2>Built-in Workflow State Triggers<a class="headerlink" href="#built-in-workflow-state-triggers" title="Permalink to this heading"></a></h2>
<p>These can be used instead of the older workflow state polling tasks described
in <a class="reference internal" href="#workflowstatepolling"><span class="std std-ref">Triggering Off Of Tasks In Other Workflows</span></a> for inter-workflow triggering - i.e. to trigger local
tasks off of remote task statuses or messages in other workflows.</p>
<p>The workflow state trigger function signature looks like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">workflow_state</span><span class="p">(</span><span class="n">workflow</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s1">&#39;succeeded&#39;</span><span class="p">,</span>
               <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cylc_run_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>The first three arguments are compulsory; they single out the target workflow name
(<code class="docutils literal notranslate"><span class="pre">workflow</span></code>) task name (<code class="docutils literal notranslate"><span class="pre">task</span></code>) and cycle point
(<code class="docutils literal notranslate"><span class="pre">point</span></code>). The function arguments mirror the arguments and options of
the <code class="docutils literal notranslate"><span class="pre">cylc</span> <span class="pre">workflow-state</span></code> command - see
<code class="docutils literal notranslate"><span class="pre">cylc</span> <span class="pre">workflow-state</span> <span class="pre">--help</span></code> for documentation.</p>
<p>As a simple example, consider the following “upstream”
workflow (which we want to trigger off of):</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduler]</span>
    <span class="nv">cycle point format </span><span class="o">=</span><span class="s"> %Y</span>
<span class="nt">[scheduling]</span>
    <span class="nv">initial cycle point </span><span class="o">=</span><span class="s"> 2005</span>
    <span class="nv">final cycle point </span><span class="o">=</span><span class="s"> 2015</span>
   <span class="nt">[[graph]]</span>
      <span class="nv">P1Y = &quot;foo </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">bar</span><span class="c">&quot;</span>
<span class="nt">[runtime]</span>
   <span class="nt">[[bar]]</span>
      <span class="nv">script </span><span class="o">=</span><span class="s"> sleep 10</span>
   <span class="nt">[[foo]]</span>
      <span class="nv">script </span><span class="o">=</span><span class="s"> sleep 5; cylc message &quot;data ready&quot;</span>
      <span class="nt">[[[outputs]]]</span>
          <span class="nv">x </span><span class="o">=</span><span class="s"> &quot;data ready&quot;</span>
</pre></div>
</div>
<p>It must be installed and run under the name <em>up</em>, as referenced in the
“downstream” workflow that depends on it:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduler]</span>
  <span class="nv">cycle point format </span><span class="o">=</span><span class="s"> %Y</span>
<span class="nt">[scheduling]</span>
    <span class="nv">initial cycle point </span><span class="o">=</span><span class="s"> 2010</span>
    <span class="nt">[[xtriggers]]</span>
         <span class="nv">upstream </span><span class="o">=</span><span class="s"> workflow_state(workflow=up, task=foo, point=%(point)s, \</span>
<span class="s">            message=&#39;data ready&#39;):PT10S</span>
         <span class="nv">clock_0 </span><span class="o">=</span><span class="s"> wall_clock(offset=PT0H)</span>
   <span class="nt">[[graph]]</span>
        <span class="nv">P1Y </span><span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
            <span class="kd">foo</span>
            <span class="cp">@clock_0</span> <span class="o">&amp;</span> <span class="cp">@upstream</span> <span class="o">=&gt;</span> <span class="kd">FAM</span><span class="c">:</span><span class="kd">succeed</span><span class="c">-</span><span class="kd">all</span> <span class="o">=&gt;</span> <span class="kd">blam</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="nt">[runtime]</span>
    <span class="nt">[[root]]</span>
        <span class="nv">script </span><span class="o">=</span><span class="s"> sleep 5</span>
    <span class="nt">[[foo, blam]]</span>
    <span class="nt">[[FAM]]</span>
    <span class="nt">[[f1,f2,f3]]</span>
        <span class="nv">inherit </span><span class="o">=</span><span class="s"> FAM</span>
</pre></div>
</div>
<p>Try starting the downstream workflow first, then the upstream, and
watch what happens.
In each cycle point the <code class="docutils literal notranslate"><span class="pre">&#64;upstream</span></code> trigger in the downstream workflow
waits on the task <code class="docutils literal notranslate"><span class="pre">foo</span></code> (with the same cycle point) in the upstream
workflow to emit the <em>data ready</em> message.</p>
<p>Some important points to note about this:</p>
<ul class="simple">
<li><p>The function call interval, which determines how often the scheduler
checks the clock, is optional. Here it is
<code class="docutils literal notranslate"><span class="pre">PT10S</span></code> (i.e. 10 seconds, which is also the default value).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">workflow_state</span></code> trigger function, like the
<code class="docutils literal notranslate"><span class="pre">cylc</span> <span class="pre">workflow-state</span></code> command, must have read-access to the upstream
workflow’s public database.</p></li>
<li><p>The cycle point argument is supplied by a string template
<code class="docutils literal notranslate"><span class="pre">%(point)s</span></code>. The string templates available to trigger function
arguments are described in <a class="reference internal" href="#custom-trigger-functions"><span class="std std-ref">Custom Trigger Functions</span></a>).</p></li>
</ul>
<p>The return value of the <code class="docutils literal notranslate"><span class="pre">workflow_state</span></code> trigger function looks like
this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;workflow&#39;</span><span class="p">:</span> <span class="n">workflow</span><span class="p">,</span>
    <span class="s1">&#39;task&#39;</span><span class="p">:</span> <span class="n">task</span><span class="p">,</span>
    <span class="s1">&#39;point&#39;</span><span class="p">:</span> <span class="n">point</span><span class="p">,</span>
    <span class="s1">&#39;offset&#39;</span><span class="p">:</span> <span class="n">offset</span><span class="p">,</span>
    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="n">status</span><span class="p">,</span>
    <span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span>
    <span class="s1">&#39;cylc_run_dir&#39;</span><span class="p">:</span> <span class="n">cylc_run_dir</span>
<span class="p">}</span>
<span class="k">return</span> <span class="p">(</span><span class="n">satisfied</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">satisfied</span></code> variable is boolean (value True or False, depending
on whether or not the trigger condition was found to be satisfied). The
<code class="docutils literal notranslate"><span class="pre">results</span></code> dictionary contains the names and values of all of the
target workflow state parameters. Each item in it gets qualified with the
unique trigger label (“upstream” here) and passed to the environment of
dependent tasks (the members of the <code class="docutils literal notranslate"><span class="pre">FAM</span></code> family in this case).
To see this, take a look at the job script for one of the downstream tasks:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>cylc<span class="w"> </span>cat-log<span class="w"> </span>-f<span class="w"> </span>j<span class="w"> </span>dn//2011/f22011
<span class="go">...</span>
<span class="go">cylc__job__inst__user_env() {</span>
<span class="gp">    # </span>TASK<span class="w"> </span>RUNTIME<span class="w"> </span>ENVIRONMENT:
<span class="go">    export upstream_workflow upstream_cylc_run_dir upstream_offset \</span>
<span class="go">      upstream_message upstream_status upstream_point upstream_task</span>
<span class="go">    upstream_workflow=&quot;up&quot;</span>
<span class="go">    upstream_cylc_run_dir=&quot;/home/vagrant/cylc-run&quot;</span>
<span class="go">    upstream_offset=&quot;None&quot;</span>
<span class="go">    upstream_message=&quot;data ready&quot;</span>
<span class="go">    upstream_status=&quot;succeeded&quot;</span>
<span class="go">    upstream_point=&quot;2011&quot;</span>
<span class="go">    upstream_task=&quot;foo&quot;}</span>
<span class="go">...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The task has to know the name (label) of the external trigger that it
depends on - “upstream” in this case - in order to use this information.
However the name could be given to the task environment in the workflow
configuration.</p>
</div>
</section>
<section id="custom-trigger-functions">
<span id="id3"></span><h2>Custom Trigger Functions<a class="headerlink" href="#custom-trigger-functions" title="Permalink to this heading"></a></h2>
<p>Trigger functions are just normal Python functions, with a few special
properties:</p>
<ul class="simple">
<li><p>they must:</p>
<ul>
<li><p>be defined in a module with the same name as the function;</p></li>
<li><p>be compatible with the same Python version that runs the scheduler
(see <a class="reference external" href="https://docs.python.org/3/library/importlib.metadata.html#requirements" title="(in Python v3.11)"><span>Distribution requirements</span></a> for the latest version specification).</p></li>
</ul>
</li>
<li><p>they can be located either:</p>
<ul>
<li><p>in <code class="docutils literal notranslate"><span class="pre">&lt;workflow-dir&gt;/lib/python/</span></code>;</p></li>
<li><p>or anywhere in your Python library path.</p></li>
</ul>
</li>
<li><p>they can take arbitrary positional and keyword arguments</p></li>
<li><p>workflow and task identity, and cycle point, can be passed to trigger
functions by using string templates in function arguments (see below)</p></li>
<li><p>integer, float, boolean, and string arguments will be recognized and
passed to the function as such</p></li>
<li><p>if a trigger function depends on files or directories (for example)
that might not exist when the function is first called, just return
unsatisfied until everything required does exist.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Trigger functions cannot store data Pythonically between invocations
because each call is executed in an independent process in the process
pool. If necessary the filesystem can be used for this purpose.</p>
</div>
<dl>
<p>Templates variables for string replacement in xtrigger functions.</p>
<p>The following string templates are available for use, if the trigger
function needs any of this information, in function arguments in the
workflow configuration.</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduling]</span>
    <span class="nv">initial cycle point </span><span class="o">=</span><span class="s"> now</span>
    <span class="nt">[[xtriggers]]</span>
        <span class="nv">my_xtrigger </span><span class="o">=</span><span class="s"> my_xtrigger_fcn(&#39;%(workflow)&#39;, &#39;%(point)&#39;)</span>
</pre></div>
</div>
<p>For an explanation of the substitution syntax, see
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting">String Formatting Operations in the Python documentation</a>.</p>
<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">point</span></span></dt>
<dd><p>The cycle point of the dependent task.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">debug</span></span></dt>
<dd><p>True if Cylc is being run in debug mode (–debug, -vv).</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">workflow_run_dir</span></span></dt>
<dd><p>The path to the workflow run directory.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">workflow_share_dir</span></span></dt>
<dd><p>The path to the workflow share directory.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">id</span></span></dt>
<dd><p>The ID of the dependent task.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">name</span></span></dt>
<dd><p>The name of the dependent task.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">user_name</span></span></dt>
<dd><p>The user account under which the workflow is being run.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">workflow</span></span></dt>
<dd><p>The workflow ID.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">workflow_name</span></span></dt>
<dd><p>The workflow ID.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 8.0.0: </span>Use <code class="docutils literal notranslate"><span class="pre">workflow</span></code> instead.</p>
</div>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">suite_name</span></span></dt>
<dd><p>The workflow ID.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 8.0.0: </span>Use <code class="docutils literal notranslate"><span class="pre">workflow</span></code> instead.</p>
</div>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">suite_run_dir</span></span></dt>
<dd><p>The path to the workflow run directory.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 8.0.0: </span>Use <code class="docutils literal notranslate"><span class="pre">workflow_run_dir</span></code> instead.</p>
</div>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">suite_share_dir</span></span></dt>
<dd><p>The path to the workflow share directory.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 8.0.0: </span>Use <code class="docutils literal notranslate"><span class="pre">workflow_share_dir</span></code> instead.</p>
</div>
</dd></dl>

</dl>

<p>Function return values should be as follows:</p>
<ul class="simple">
<li><p>if the trigger condition is <em>not satisfied</em>:</p>
<ul>
<li><p>return <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">{})</span></code></p></li>
</ul>
</li>
<li><p>if the trigger condition is <em>satisfied</em>:</p>
<ul>
<li><p>return <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">results)</span></code></p></li>
</ul>
</li>
</ul>
<p>where <code class="docutils literal notranslate"><span class="pre">results</span></code> is an arbitrary dictionary of information to be passed to
dependent tasks, which in terms of format must:</p>
<ul class="simple">
<li><p>be <em>flat</em> (non-nested);</p></li>
<li><p>contain <em>only</em> keys which are
<a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html">valid</a> as environment variable names.</p></li>
</ul>
<p>See <a class="reference internal" href="#built-in-workflow-state-triggers"><span class="std std-ref">Built-in Workflow State Triggers</span></a> for an example of one such
<code class="docutils literal notranslate"><span class="pre">results</span></code> dictionary and how it gets processed by the workflow.</p>
<p>The <a class="reference internal" href="../../glossary.html#term-scheduler"><span class="xref std std-term">scheduler</span></a> manages trigger functions as follows:</p>
<ul class="simple">
<li><p>they are called asynchronously in the process pool
- (except for clock triggers, which are called from the main process)</p></li>
<li><p>they are called repeatedly on a configurable interval, until satisfied
- the call interval defaults to <code class="docutils literal notranslate"><span class="pre">PT10S</span></code> (10 seconds)
- repeat calls are not made until the previous call has returned</p></li>
<li><p>they are subject to the normal process pool command time out - if they
take too long to return, the process will be killed</p></li>
<li><p>they are shared for efficiency: a single call will be made for all
triggers that share the same function signature - i.e.the same function
name and arguments</p></li>
<li><p>their return status and results are stored in the workflow DB and persist across
workflow restarts</p></li>
<li><p>their stdout, if any, is redirected to stderr and will be visible in
the workflow log in debug mode (stdout is needed to communicate return values
from the sub-process in which the function executes)</p></li>
</ul>
<section id="toy-examples">
<h3>Toy Examples<a class="headerlink" href="#toy-examples" title="Permalink to this heading"></a></h3>
<section id="echo">
<h4>echo<a class="headerlink" href="#echo" title="Permalink to this heading"></a></h4>
<p>The trivial built-in <code class="docutils literal notranslate"><span class="pre">echo</span></code> function takes any number of positional
and keyword arguments (from the workflow configuration) and simply prints
them to stdout, and then returns False (i.e. trigger condition not
satisfied). Here it is in its entirety.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;echo: ARGS:&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;echo: KWARGS:&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">{}</span>
</pre></div>
</div>
<p>Here’s an example echo trigger workflow:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduling]</span>
    <span class="nv">initial cycle point </span><span class="o">=</span><span class="s"> now</span>
    <span class="nt">[[xtriggers]]</span>
        <span class="nv">echo_1 </span><span class="o">=</span><span class="s"> echo(hello, 99, qux=True, point=%(point)s, foo=10)</span>
    <span class="nt">[[graph]]</span>
        <span class="nv">PT1H = &quot;@echo_1 </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">foo</span><span class="c">&quot;</span>
<span class="nt">[runtime]</span>
    <span class="nt">[[foo]]</span>
        <span class="nv">script </span><span class="o">=</span><span class="s"> exit 1</span>
</pre></div>
</div>
<p>To see the result, run this workflow in debug mode and take a look at the
workflow log (or run <code class="docutils literal notranslate"><span class="pre">cylc</span> <span class="pre">play</span> <span class="pre">--debug</span> <span class="pre">--no-detach</span> <span class="pre">&lt;workflow&gt;</span></code> and watch
your terminal).</p>
</section>
<section id="xrandom">
<h4>xrandom<a class="headerlink" href="#xrandom" title="Permalink to this heading"></a></h4>
<p>The built-in <code class="docutils literal notranslate"><span class="pre">xrandom</span></code> function sleeps for a configurable amount of
time (useful for testing the effect of a long-running trigger function
- which should be avoided) and has a configurable random chance of
success. The function signature is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xrandom</span><span class="p">(</span><span class="n">percent</span><span class="p">,</span> <span class="n">secs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">percent</span></code> argument sets the odds of success in any given call;
<code class="docutils literal notranslate"><span class="pre">secs</span></code> is the number of seconds to sleep before returning; and the
<code class="docutils literal notranslate"><span class="pre">_</span></code> argument (underscore is a conventional name for a variable
that is not used, in Python) is provided to allow specialization of the
trigger to (for example) task name, task ID, or cycle point (just use
the appropriate string templates in the workflow configuration for this).</p>
<p>An example xrandom trigger workflow:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduling]</span>
    <span class="nv">cycling mode </span><span class="o">=</span><span class="s"> integer</span>
    <span class="nv">initial cycle point </span><span class="o">=</span><span class="s"> 1</span>
    <span class="nv">final cycle point </span><span class="o">=</span><span class="s"> 5</span>
    <span class="nt">[[xtriggers]]</span>
        <span class="c1"># Called once for all dependent tasks (all cycles).</span>
        <span class="nv">x1 </span><span class="o">=</span><span class="s"> xrandom(percent=25, secs=2):PT5S</span>
        <span class="c1"># Called once per dependent task name (all cycles).</span>
        <span class="nv">x2 </span><span class="o">=</span><span class="s"> xrandom(percent=25, secs=2, _=%(name)s):PT5S</span>
        <span class="c1"># Called once per cycle for all dependent tasks.</span>
        <span class="nv">x3 </span><span class="o">=</span><span class="s"> xrandom(percent=25, secs=2, _=%(point)s):PT5S</span>
    <span class="nt">[[graph]]</span>
        <span class="nv">P1 </span><span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
            <span class="c1"># all instances of foo and bar should trigger at once, together</span>
            <span class="cp">@x1</span> <span class="o">=&gt;</span> <span class="kd">foo</span> <span class="o">&amp;</span> <span class="kd">bar</span>

            <span class="c1"># all instances of cat should trigger at once, and separately, all</span>
            <span class="c1"># instances of baz should trigger at once.</span>
            <span class="cp">@x2</span> <span class="o">=&gt;</span> <span class="kd">cat</span> <span class="o">&amp;</span> <span class="kd">dog</span>

            <span class="c1"># each instance of qux should trigger separately</span>
            <span class="cp">@x3</span> <span class="o">=&gt;</span> <span class="kd">qux</span>

            <span class="c1"># Result:</span>
            <span class="c1"># - x1 should return True once, and not be called again.</span>
            <span class="c1"># - x2 should return True twice, and not be called again.</span>
            <span class="c1"># - x3 should return True five times, and not be called again.</span>
            <span class="c1"># i.e. 8 True returns in the 5-cycle workflow run.</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="nt">[runtime]</span>
    <span class="nt">[[root]]</span>
        <span class="nv">script </span><span class="o">=</span><span class="s"> sleep 5</span>
    <span class="nt">[[foo, bar, cat, dog, qux]]</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="current-limitations">
<span id="current-trigger-function-limitations"></span><h2>Current Limitations<a class="headerlink" href="#current-limitations" title="Permalink to this heading"></a></h2>
<p>The following issues may be addressed in future Cylc releases:</p>
<ul class="simple">
<li><p>trigger labels cannot currently be used in conditional (OR) expressions
in the graph; attempts to do so will fail validation.</p></li>
<li><p>aside from the predefined zero-offset <code class="docutils literal notranslate"><span class="pre">wall_clock</span></code> trigger, all
unique trigger function calls must be declared <em>with all of
their arguments</em> under the <a class="reference internal" href="../../reference/config/workflow.html#flow.cylc[scheduling][xtriggers]" title="flow.cylc[scheduling][xtriggers]"><code class="xref cylc cylc-conf docutils literal notranslate"><span class="pre">[xtriggers]</span></code></a> section, and
referred to by label alone in the graph. It would be convenient (and less
verbose, although no more functional) if we could just declare a label
against the <em>common</em> arguments, and give remaining arguments (such as
different wallclock offsets in clock triggers) as needed in the graph.</p></li>
<li><p>we may move away from the string templating method for providing workflow
and task attributes to trigger function arguments.</p></li>
</ul>
</section>
<section id="filesystem-events">
<h2>Filesystem Events?<a class="headerlink" href="#filesystem-events" title="Permalink to this heading"></a></h2>
<p>Cylc does not have built-in support for triggering off of filesystem events
such as <code class="docutils literal notranslate"><span class="pre">inotify</span></code> on Linux. There is no cross-platform standard for
this, and in any case filesystem events are not very useful in HPC cluster
environments where events can only be detected at the specific node on which
they were generated.</p>
</section>
<section id="continuous-event-watchers">
<h2>Continuous Event Watchers?<a class="headerlink" href="#continuous-event-watchers" title="Permalink to this heading"></a></h2>
<p>For some applications a persistent process that continually monitors the
external world is better than discrete periodic checking. This would be more
difficult to support as a plugin mechanism in Cylc, but we may decide to do it
in the future. In the meantime, consider implementing a small daemon process as
the watcher (e.g. to watch continuously for filesystem events) and have your
Cylc trigger functions interact with it.</p>
</section>
<section id="push-external-triggers">
<span id="old-style-external-triggers"></span><h2>Push External Triggers<a class="headerlink" href="#push-external-triggers" title="Permalink to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The external triggering mechanism described here is harder to use than the
newer method of <a class="reference internal" href="#section-external-triggers"><span class="std std-ref">External Triggers</span></a>. The trigger is a task
property rather than something the task depends on, it requires the
external system to push a message to the scheduler, and it has a less
flexible way to pass information to downstream tasks. However, a push
mechanism may sometimes be preferred over polling by the scheduler, so we
have retained support pending something better in a future Cylc 8 release.</p>
</div>
<p>These external triggers are hidden task prerequisites that must be satisfied by
using the <code class="docutils literal notranslate"><span class="pre">cylc</span> <span class="pre">ext-trigger</span></code> client command to send a pre-defined message to
the workflow along with an ID string that distinguishes one instance of the
event from another (the name of the target task and its current cycle point are
not required). The event ID is just an arbitrary string to Cylc, but it can be
used to identify something associated with the event to the workflow - such as
the filename of a new externally-generated dataset. When the <a class="reference internal" href="../../glossary.html#term-scheduler"><span class="xref std std-term">scheduler</span></a>
receives the event notification it will trigger the next instance of any task
waiting on that trigger (whatever its cycle point) and then broadcast
(see <a class="reference internal" href="../running-workflows/dynamic-behaviour.html#cylc-broadcast"><span class="std std-ref">Cylc Broadcast</span></a>) the event ID to the cycle point of the triggered
task as <code class="docutils literal notranslate"><span class="pre">$CYLC_EXT_TRIGGER_ID</span></code>. Downstream tasks with the same cycle
point therefore know the new event ID too and can use it, if they need to, to
identify the same new dataset. In this way a whole workflow can be associated
with each new dataset, and multiple datasets can be processed in parallel if
they happen to arrive in quick succession.</p>
<p>An externally-triggered task must register the event it waits on in the workflow
scheduling section:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="c1"># workflow &quot;sat-proc&quot;</span>
<span class="nt">[scheduling]</span>
    <span class="nv">cycling mode </span><span class="o">=</span><span class="s"> integer</span>
    <span class="nv">initial cycle point </span><span class="o">=</span><span class="s"> 1</span>
    <span class="nt">[[special tasks]]</span>
        <span class="nv">external-trigger </span><span class="o">=</span><span class="s"> get-data(&quot;new sat X data avail&quot;)</span>
    <span class="nt">[[graph]]</span>
        <span class="nv">P1 = get-data =&gt; conv-data </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">products</span>
</pre></div>
</div>
<p>Then, each time a new dataset arrives the external detection system should
notify the workflow like this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cylc<span class="w"> </span>ext-trigger<span class="w"> </span>sat-proc<span class="w"> </span><span class="s2">&quot;new sat X data avail&quot;</span><span class="w"> </span>passX12334a
</pre></div>
</div>
<p>where “sat-proc” is the workflow name and “passX12334a” is the ID string for
the new event. The workflow passphrase must be installed on triggering account.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only one task in a workflow can trigger off a particular external message.
Other tasks can trigger off the externally triggered task as required,
of course.</p>
</div>
<p>Here is a working example of a simulated satellite processing workflow:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="ch">#!Jinja2</span>

<span class="c1"># WARNING: this uses the old-style push external trigger mechanism.</span>

<span class="nt">[meta]</span>
    <span class="nv">title </span><span class="o">=</span><span class="s"> Real time satellite data processing demo, variant 3 of 3</span>

    <span class="nv">description </span><span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Successive cycle points retrieve and process the next arbitrarily timed</span>
<span class="s2">        and labelled dataset, in parallel if the data comes in quickly. This</span>
<span class="s2">        variant of the workflow has initial get_data tasks with external triggers:</span>
<span class="s2">        they do not submit until triggered by an external system.</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="c1"># Note that the satellite simulator task here that supplies the external event</span>
<span class="c1"># trigger happens to be a workflow task - i.e. it is not really &quot;external&quot; - but</span>
<span class="c1"># this is only a convenience - an easy route to a self-contained example workflow.</span>

<span class="c1"># you can monitor output processing with:</span>
<span class="c1"># $ watch -n 1 \</span>
<span class="c1">#    &quot;find ~/cylc-run/&lt;workflow-id&gt;/share; find ~/cylc-run/&lt;workflow-id&gt;/work&quot;</span>

<span class="cp">{% set N_DATASETS = 5 %}</span>

<span class="c1"># define shared directories (could use runtime namespaces for this)</span>
<span class="cp">{% set DATA_IN_DIR = &quot;$CYLC_WORKFLOW_SHARE_DIR/incoming&quot; %}</span>
<span class="cp">{% set PRODUCT_DIR = &quot;$CYLC_WORKFLOW_SHARE_DIR/products&quot; %}</span>

<span class="nt">[scheduling]</span>
    <span class="nv">cycling mode </span><span class="o">=</span><span class="s"> integer</span>
    <span class="nv">initial cycle point </span><span class="o">=</span><span class="s"> 1</span>
    <span class="nv">final cycle point </span><span class="o">=</span><span class="s"> </span><span class="cp">{{N_DATASETS}}</span>
    <span class="nt">[[special tasks]]</span>
        <span class="nv">external-trigger </span><span class="o">=</span><span class="s"> get_data(&quot;new dataset ready for processing&quot;)</span>
    <span class="nt">[[graph]]</span>
        <span class="c1"># first cycle</span>
        <span class="nv">R1 = prep </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">satsim</span> <span class="o">&amp;</span> <span class="kd">get_data</span>
<span class="nv">        P1 </span><span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
            <span class="c1"># Processing chain for each dataset</span>
            <span class="kd">get_data</span> <span class="o">=&gt;</span> <span class="kd">proc1</span> <span class="o">=&gt;</span> <span class="kd">proc2</span> <span class="o">=&gt;</span> <span class="kd">products</span>
            <span class="c1"># As one dataset is retrieved, start waiting on another.</span>
            <span class="kd">get_data</span>[<span class="nb">-P1</span>] <span class="o">=&gt;</span> <span class="kd">get_data</span>
        <span class="s2">&quot;&quot;&quot;</span>
        <span class="c1"># last cycle</span>
        <span class="nv">R1//{{N_DATASETS}} = products </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">collate</span>

<span class="nt">[runtime]</span>
    <span class="nt">[[prep]]</span>
        <span class="nv">script </span><span class="o">=</span><span class="s"> \</span>
<span class="s">rm -rf $CYLC_WORKFLOW_SHARE_DIR $CYLC_WORKFLOW_WORK_DIR</span>
        <span class="nt">[[[meta]]]</span>
            <span class="nv">title </span><span class="o">=</span><span class="s"> clean the workflow output directories</span>
    <span class="nt">[[satsim]]</span>
        <span class="nv">pre-script </span><span class="o">=</span><span class="s"> mkdir -p </span><span class="cp">{{DATA_IN_DIR}}</span>
        <span class="nv">script </span><span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            COUNT=0</span>
<span class="s2">            while true; do</span>
<span class="s2">                ((COUNT == </span><span class="cp">{{N_DATASETS}}</span><span class="s2">)) &amp;&amp; break</span>
                <span class="c1"># sleep $((RANDOM % 20))</span>
                <span class="c1"># Generate datasets very quickly to test parallel processing.</span>
<span class="s2">                DATA_ID=$(date +%s).$((RANDOM % 100))</span>
<span class="s2">                DATA_FILE=dataset-${DATA_ID}.raw</span>
<span class="s2">                touch </span><span class="cp">{{DATA_IN_DIR}}</span><span class="s2">/$DATA_FILE</span>
<span class="s2">                ((COUNT += 1))</span>
                <span class="c1"># (required to distinguish fast-arriving messages).</span>
                <span class="c1"># Trigger downstream processing in the workflow.</span>
<span class="s2">                cylc ext-trigger $CYLC_WORKFLOW_ID \</span>
<span class="s2">                   &quot;new dataset ready for processing&quot; $DATA_ID</span>
<span class="s2">            done</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nt">[[[meta]]]</span>
            <span class="nv">title </span><span class="o">=</span><span class="s"> simulate a satellite data feed</span>
            <span class="nv">description </span><span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                Generates </span><span class="cp">{{N_DATASETS}}</span><span class="s2"> arbitrarily labelled datasets very</span>
<span class="s2">                quickly, to show parallel processing streams.</span>
<span class="s2">            &quot;&quot;&quot;</span>
    <span class="nt">[[WORKDIR]]</span>
        <span class="c1"># Define a common cycle-point-specific work-directory for all</span>
        <span class="c1"># processing tasks so that they all work on the same dataset.</span>
        <span class="nv">work sub-directory </span><span class="o">=</span><span class="s"> proc-$CYLC_TASK_CYCLE_POINT</span>
        <span class="nv">post-script </span><span class="o">=</span><span class="s"> sleep 5</span>
        <span class="nt">[[[environment]]]</span>
            <span class="nv">DATASET </span><span class="o">=</span><span class="s"> dataset-$CYLC_EXT_TRIGGER_ID</span>

    <span class="nt">[[get_data]]</span>
        <span class="nv">inherit </span><span class="o">=</span><span class="s"> WORKDIR</span>
        <span class="nv">script </span><span class="o">=</span><span class="s"> mv </span><span class="cp">{{DATA_IN_DIR}}</span><span class="s">/${DATASET}.raw $PWD</span>
        <span class="nt">[[[meta]]]</span>
            <span class="nv">title </span><span class="o">=</span><span class="s"> retrieve next dataset</span>
            <span class="nv">description </span><span class="o">=</span><span class="s"> just do it - we know it exists already</span>
  <span class="nt">[[proc1]]</span>
        <span class="nv">inherit </span><span class="o">=</span><span class="s"> WORKDIR</span>
        <span class="nv">script </span><span class="o">=</span><span class="s"> mv ${DATASET}.raw ${DATASET}.proc1</span>
        <span class="nt">[[[meta]]]</span>
            <span class="nv">title </span><span class="o">=</span><span class="s"> convert .raw dataset to .proc1 form</span>
   <span class="nt">[[proc2]]</span>
        <span class="nv">inherit </span><span class="o">=</span><span class="s"> WORKDIR</span>
        <span class="nv">script </span><span class="o">=</span><span class="s"> mv ${DATASET}.proc1 ${DATASET}.proc2</span>
        <span class="nt">[[[meta]]]</span>
            <span class="nv">title </span><span class="o">=</span><span class="s"> convert .proc1 dataset to .proc2 form</span>
   <span class="nt">[[products]]</span>
        <span class="nv">inherit </span><span class="o">=</span><span class="s"> WORKDIR</span>
        <span class="nv">script </span><span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            mkdir -p </span><span class="cp">{{PRODUCT_DIR}}</span>
<span class="s2">            mv ${DATASET}.proc2 </span><span class="cp">{{PRODUCT_DIR}}</span><span class="s2">/${DATASET}.prod</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nt">[[[meta]]]</span>
            <span class="nv">title </span><span class="o">=</span><span class="s"> generate products from .proc2 processed dataset</span>
    <span class="nt">[[collate]]</span>
        <span class="c1"># Note you might want to use &quot;cylc workflow-state&quot; to check that</span>
        <span class="c1"># _all_ product tasks have finished before collating results.</span>
        <span class="nv">script </span><span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            echo PRODUCTS:</span>
<span class="s2">            ls </span><span class="cp">{{PRODUCT_DIR}}</span>
<span class="s2">            sleep 20</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nt">[[[meta]]]</span>
            <span class="nv">title </span><span class="o">=</span><span class="s"> collate all products from the workflow run</span>
</pre></div>
</div>
<p>External triggers are not normally needed in datetime cycling workflows driven
by real time data that comes in at regular intervals. In these cases a data
retrieval task can be clock-triggered (and have appropriate retry intervals) to
submit at the expected data arrival time, so little time is wasted in polling.
However, if the arrival time of the cycle-point-specific data is highly
variable, external triggering may be used with the cycle point embedded in the
message:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="c1"># workflow &quot;data-proc&quot;</span>
<span class="nt">[scheduling]</span>
    <span class="nv">initial cycle point </span><span class="o">=</span><span class="s"> 20150125T00</span>
    <span class="nv">final cycle point   </span><span class="o">=</span><span class="s"> 20150126T00</span>
    <span class="nt">[[special tasks]]</span>
        <span class="nv">external-trigger </span><span class="o">=</span><span class="s"> get-data(&quot;data arrived for $CYLC_TASK_CYCLE_POINT&quot;)</span>
    <span class="nt">[[graph]]</span>
        <span class="nv">T00 = init-process =&gt; get-data </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">post</span><span class="c">-</span><span class="kd">process</span>
</pre></div>
</div>
<p>Once the variable-length waiting is finished, an external detection system
should notify the workflow like this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cylc<span class="w"> </span>ext-trigger<span class="w"> </span>data-proc<span class="w"> </span><span class="s2">&quot;data arrived for 20150126T00&quot;</span><span class="w"> </span>passX12334a
</pre></div>
</div>
<p>where “data-proc” is the workflow name, the cycle point has replaced the
variable in the trigger string, and “passX12334a” is the ID string for
the new event. The workflow passphrase must be installed on the triggering
account. In this case, the event will trigger for the second cycle point but
not the first because of the cycle-point matching.</p>
</section>
<section id="triggering-off-of-tasks-in-other-workflows">
<span id="workflowstatepolling"></span><h2>Triggering Off Of Tasks In Other Workflows<a class="headerlink" href="#triggering-off-of-tasks-in-other-workflows" title="Permalink to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please read <a class="reference internal" href="#section-external-triggers"><span class="std std-ref">External Triggers</span></a> before using the older
inter-workflow triggering mechanism described in this section.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cylc</span> <span class="pre">workflow-state</span></code> command interrogates workflow run databases. It
has a polling mode that waits for a given task in the target workflow to achieve a
given state, or receive a given message. This can be used to make task
scripting wait for a remote task to succeed (for example).</p>
<p>Automatic workflow-state polling tasks can be defined with in the graph. They get
automatically-generated task scripting that uses <code class="docutils literal notranslate"><span class="pre">cylc</span> <span class="pre">workflow-state</span></code>
appropriately (it is an error to give your own <code class="docutils literal notranslate"><span class="pre">script</span></code> item for these
tasks).</p>
<p>Here’s how to trigger a task <code class="docutils literal notranslate"><span class="pre">bar</span></code> off a task <code class="docutils literal notranslate"><span class="pre">foo</span></code> in
a remote workflow called <code class="docutils literal notranslate"><span class="pre">other.workflow</span></code>:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduling]</span>
    <span class="nt">[[graph]]</span>
        <span class="nv">T00, T12 = &quot;my-foo&lt;other.workflow::foo&gt; </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">bar</span><span class="c">&quot;</span>
</pre></div>
</div>
<p>Local task <code class="docutils literal notranslate"><span class="pre">my-foo</span></code> will poll for the success of <code class="docutils literal notranslate"><span class="pre">foo</span></code>
in workflow <code class="docutils literal notranslate"><span class="pre">other.workflow</span></code>, at the same cycle point, succeeding only when
or if it succeeds. Other task states can also be polled:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nv">T00, T12 </span><span class="o">=</span><span class="s"> &quot;my-foo&lt;other.workflow::foo:fail&gt; =&gt; bar&quot;</span>
</pre></div>
</div>
<p>The default polling parameters (e.g. maximum number of polls and the interval
between them) are printed by <code class="docutils literal notranslate"><span class="pre">cylc</span> <span class="pre">workflow-state</span> <span class="pre">--help</span></code> and can be
configured if necessary under the local polling task runtime section:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduling]</span>
    <span class="nt">[[graph]]</span>
        <span class="nv">T00,T12 = &quot;my-foo&lt;other.workflow::foo&gt; </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">bar</span><span class="c">&quot;</span>
<span class="nt">[runtime]</span>
    <span class="nt">[[my-foo]]</span>
        <span class="nt">[[[workflow state polling]]]</span>
            <span class="nv">max-polls </span><span class="o">=</span><span class="s"> 100</span>
            <span class="nv">interval </span><span class="o">=</span><span class="s"> PT10S</span>
</pre></div>
</div>
<p>To poll for the target task to receive a message rather than achieve a state,
give the message in the runtime configuration (in which case the task status
inferred from the graph syntax will be ignored):</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[runtime]</span>
    <span class="nt">[[my-foo]]</span>
        <span class="nt">[[[workflow state polling]]]</span>
            <span class="nv">message </span><span class="o">=</span><span class="s"> &quot;the quick brown fox&quot;</span>
</pre></div>
</div>
<p>For workflows owned by others, or those with run databases in non-standard
locations, use the <code class="docutils literal notranslate"><span class="pre">--run-dir</span></code> option, or in-workflow:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[runtime]</span>
    <span class="nt">[[my-foo]]</span>
        <span class="nt">[[[workflow state polling]]]</span>
            <span class="nv">run-dir </span><span class="o">=</span><span class="s"> /path/to/top/level/cylc/run-directory</span>
</pre></div>
</div>
<p>If the remote task has a different cycling sequence, just arrange for the
local polling task to be on the same sequence as the remote task that it
represents. For instance, if local task <code class="docutils literal notranslate"><span class="pre">cat</span></code> cycles 6-hourly at
<code class="docutils literal notranslate"><span class="pre">0,6,12,18</span></code> but needs to trigger off a remote task <code class="docutils literal notranslate"><span class="pre">dog</span></code>
at <code class="docutils literal notranslate"><span class="pre">3,9,15,21</span></code>:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduling]</span>
    <span class="nt">[[graph]]</span>
        <span class="nv">T03,T09,T15,T21 </span><span class="o">=</span> <span class="c">&quot;</span><span class="kd">my</span><span class="c">-</span><span class="kd">dog</span>&lt;<span class="bp">other.workflow</span>::<span class="nb">dog</span>&gt;<span class="c">&quot;</span>
<span class="nv">        T00,T06,T12,T18 = &quot;my-dog[-PT3H] </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">cat</span><span class="c">&quot;</span>
</pre></div>
</div>
<p>For workflow-state polling, the cycle point is automatically converted to the
cycle point format of the target workflow.</p>
<p>The remote workflow does not have to be running when polling commences because the
command interrogates the workflow run database, not the <a class="reference internal" href="../../glossary.html#term-scheduler"><span class="xref std std-term">scheduler</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The graph syntax for workflow polling tasks cannot be combined with
cycle point offsets, family triggers, or parameterized task notation.
This does not present a problem because workflow polling tasks can be put on
the same cycling sequence as the remote-workflow target task (as recommended
above), and there is no point in having multiple tasks (family members or
parameterized tasks) performing the same polling operation. Task state
triggers can be used with workflow polling, e.g. to trigger another task if
polling fails after 10 tries at 10 second intervals:</p>
<div class="highlight-cylc notranslate"><div class="highlight"><pre><span></span><span class="nt">[scheduling]</span>
    <span class="nt">[[graph]]</span>
        <span class="nv">R1 = &quot;poller&lt;other-workflow::foo:succeed&gt;:fail </span><span class="o">=</span><span class="c">&gt;</span> <span class="kd">another</span><span class="c">-</span><span class="kd">task</span><span class="c">&quot;</span>
<span class="nt">[runtime]</span>
    <span class="nt">[[my-foo]]</span>
        <span class="nt">[[[workflow state polling]]]</span>
            <span class="nv">max-polls </span><span class="o">=</span><span class="s"> 10</span>
            <span class="nv">interval </span><span class="o">=</span><span class="s"> PT10S</span>
</pre></div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="empy.html" class="btn btn-neutral float-left" title="EmPy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="suicide-triggers.html" class="btn btn-neutral float-right" title="Suicide Triggers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2008-2023 NIWA &amp; British Crown (Met Office) &amp; Contributors.
      <span class="lastupdated">Last updated on Jan 19, 2023.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <!--
  element which gets populated with the list of available versions and
  formats for the documentation by versions.js
-->
<div
  class="rst-versions"
  data-toggle="rst-versions"
  id='versions-and-formats'
></div>




<script type="text/javascript">
    const CUR_FORMAT = "html";
    const CUR_VERSION = "8.1.0";
    // name of page (in URL), for singlepage builds this will be `index`
    const PAGE_NAME = "user-guide/writing-workflows/external-triggers";
    // URL path to the base docs dir i.e. ROOT_DIR/version/format
    const ROOT_DIR = "../../../..";
</script>

<script
  type="text/javascript"
  src="../../../../versions.js"
></script><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>